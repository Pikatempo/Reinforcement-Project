(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['@sandstreamdev/std'] = {}));
}(this, (function (exports) { 'use strict';

    var any$1 = (xs) => (xs ? xs.length > 0 : false);

    var is$1 = (value) => Array.isArray(value);

    var areArrays = (...xs) => xs.every(is$1);

    var range$1 = (n) => Array(n)
        .fill(0)
        .map((_, index) => index);

    var chunk = (count) => (xs) => {
        if (count > 0) {
            const chunks = Math.ceil(xs.length / count);
            return chunks > 0
                ? range$1(chunks).map(i => xs.slice(i * count, (i + 1) * count))
                : xs;
        }
        return [];
    };

    var difference = (xs, ys) => {
        const zs = new Set(ys);
        return xs.filter(x => !zs.has(x));
    };

    var isNonNullable = (val) => val !== undefined && val !== null;

    var differs = (xs, ys) => Boolean(!xs && ys) ||
        Boolean(!ys && xs) ||
        !isNonNullable(ys) ||
        !isNonNullable(xs) ||
        xs.length !== ys.length ||
        xs.some((x, index) => x !== ys[index]);

    var duplicates = (xs) => xs.filter((value, index, self) => self.indexOf(value) !== index);

    var empty$3 = [];

    var exact = (count) => (xs) => range$1(count).map(index => xs[index]);

    var except = (y) => (xs) => xs.filter(x => x !== y);

    var filterInPlace = (f) => (xs) => {
        let i = 0;
        let j = 0;
        while (i < xs.length) {
            const value = xs[i];
            if (f(value, i, xs)) {
                xs[j++] = value;
            }
            i++;
        }
        xs.length = j;
        return xs;
    };

    var find$1 = (predicate, fallback) => (xs) => {
        const targetIndex = xs.findIndex(predicate);
        return targetIndex !== -1 ? xs[targetIndex] : fallback;
    };

    var first$1 = ([x]) => x;

    var flatMap = (f) => (xs) => xs.reduce((ys, value, index, context) => ys.concat(f(value, index, context)), []);

    var flatten = (xs) => [].concat(...xs);

    var insert = (index) => (item) => ([...xs]) => {
        xs.splice(index, 0, item);
        return xs;
    };

    var intersection = (xs, ys) => xs.filter(value => ys.includes(value));

    var last = (xs) => xs[xs.length - 1];

    var length$3 = (xs) => xs.length;

    var lengthDiffers = (a, b) => a.length !== b.length;

    var map$1 = (...fs) => {
        const f = (x) => fs.reduce((x, f) => f(x), x);
        return (xs) => xs.map(f);
    };

    var midpoint = (xs) => xs[Math.floor(xs.length / 2)];

    var minMax$1 = (xs) => {
        const [head, ...tail] = xs;
        return tail.reduce(([min, max], current) => [Math.min(min, current), Math.max(max, current)], [head, head]);
    };

    var multiple = (xs) => xs.length > 1;

    var none$1 = (xs) => !any$1(xs);

    var partition = (predicate) => (xs) => xs.reduce(([left, right], current) => {
        const pass = predicate(current);
        return pass ? [left, [...right, current]] : [[...left, current], right];
    }, [[], []]);

    var take = (count) => (xs) => xs.slice(0, count);

    var pop = (xs) => take(xs.length - 1)(xs);

    var removeAt = (index) => (xs) => {
        if (index >= xs.length || index < 0) {
            return xs;
        }
        const ys = [...xs];
        ys.splice(index, 1);
        return ys;
    };

    var repeat = (count) => (value) => Array(count).fill(value);

    var reverse = (xs) => [...xs].reverse();

    var reverseIf = (enabled) => (xs) => (enabled ? reverse(xs) : xs);

    var second = (xs) => {
        const [, x] = xs;
        return x;
    };

    var secondToLast = (xs) => xs[xs.length - 2];

    var shift = (count) => (xs) => xs.map((_, index) => xs[(index + (count % xs.length) + xs.length) % xs.length]);

    var shuffleInPlace = (xs, random = Math.random) => {
        for (let i = 0; i < xs.length; i++) {
            const j = Math.floor(random() * (i + 1));
            [xs[i], xs[j]] = [xs[j], xs[i]];
        }
        return xs;
    };

    var shuffle = (xs, random) => shuffleInPlace([...xs], random);

    var single = (xs) => xs.length === 1;

    var skip = (count) => (xs) => xs.slice(count, xs.length);

    var slidingWindow = (count) => (xs) => xs
        .map((_, index, source) => source.slice(index, index + count))
        .filter(element => element.length > 0 && element.length === count);

    var sort$1 = (f) => (xs) => [...xs].sort(f);

    const add$2 = (a, b) => a + b;
    var sum = (xs) => xs.reduce(add$2, 0);

    var unique = (xs) => [...new Set(xs)];

    var uniqueBy = (f) => (xs) => [
        ...new Map(xs.map(x => [f(x), x])).values()
    ];

    const pair = (x, y) => [x, y];
    var zipWith = (f = pair) => (xs, ys) => xs.map((x, index) => f(x, ys[index]));

    var zip = zipWith((x, y) => [x, y]);

    var zipN = (...xs) => {
        const [head = [], ...tail] = xs;
        return head.map((value, index) => tail.reduce((x, xs) => [...x, xs[index]], [value]));
    };

    var array$1 = { any: any$1, are: areArrays, chunk, difference, differs, duplicates, empty: empty$3, exact, except, filterInPlace, find: find$1, first: first$1, flatMap, flatten, insert, intersection, is: is$1, last, length: length$3, lengthDiffers, map: map$1, midpoint, minMax: minMax$1, multiple, none: none$1, partition, pop, range: range$1, removeAt, repeat, reverse, reverseIf, second, secondToLast, shift, shuffle, shuffleInPlace, single, skip, slidingWindow, sort: sort$1, sum, take, unique, uniqueBy, zip, zipN, zipWith };

    /* eslint-env browser */
    var debounce = (f, wait) => {
        let timeout;
        return (...args) => {
            const resolve = () => {
                timeout = null;
                f(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(resolve, wait);
        };
    };

    /* eslint-env browser, node */
    var delay = (duration) => new Promise(resolve => setTimeout(resolve, duration));

    var sequence = async (tasks) => {
        const results = tasks.map(() => undefined);
        await tasks.reduce(async (chain, current, i) => {
            await chain;
            const x = await current();
            results[i] = x;
            return x;
        }, Promise.resolve());
        return results;
    };

    var async = { debounce, delay, sequence };

    var clamp$1 = (min, max) => (date) => {
        const clamped = new Date(Math.min(max.valueOf(), Math.max(min.valueOf(), date.valueOf())));
        return clamped;
    };

    var clone = (date) => new Date(date);

    var dateDiff = (a, b) => a.valueOf() - b.valueOf();

    var dateInRange = (from, to) => (date) => {
        const timestamp = date.valueOf();
        const fromTimestamp = from.valueOf();
        const toTimestamp = to.valueOf();
        return timestamp >= fromTimestamp && timestamp <= toTimestamp;
    };

    var endOfDay = (date) => {
        const copy = clone(date);
        copy.setHours(24, 0, 0, 0);
        return copy;
    };

    var startOfDay = (date) => {
        const copy = clone(date);
        copy.setHours(0, 0, 0, 0);
        return copy;
    };

    var dayRange = (date) => [startOfDay(date), endOfDay(date)];

    var daysInMonths = (leapYear) => [31, leapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

    var leapYear = (year) => new Date(year, 1, 29).getMonth() === 1;

    var daysInYear = (year) => (leapYear(year) ? 366 : 365);

    var displayTime = (source, showSeconds) => {
        const [hours, minutes, seconds] = source.map(_ => `${_}`);
        const padded = [hours, minutes, seconds].map(x => x.padStart(2, "0"));
        const [paddedHours, paddedMinutes] = padded;
        const parts = showSeconds ? padded : [paddedHours, paddedMinutes];
        return parts.join(":");
    };

    var formatDate = (date) => {
        const [m, a, y] = [
            date.getMonth() + 1,
            date.getDate(),
            date.getFullYear()
        ].map(_ => _ + "");
        return [y.padStart(4, "0"), m.padStart(2, "0"), a.padStart(2, "0")].join("-");
    };

    var formatTime = (date, showSeconds = false) => {
        const [hours, minutes, seconds] = [
            date.getHours(),
            date.getMinutes(),
            date.getSeconds()
        ];
        return displayTime([hours, minutes, seconds], showSeconds);
    };

    var formatDateTime = (sourceDate, showSeconds = false) => {
        const date = formatDate(sourceDate);
        const time = formatTime(sourceDate, showSeconds);
        return `${date} ${time}`;
    };

    var fromSeconds = (seconds) => seconds * 1000;

    var fromMinutes = (minutes) => fromSeconds(minutes * 60);

    var fromHours = (hours) => fromMinutes(hours * 60);

    var toSeconds = (milliseconds) => milliseconds / 1000;

    var toMinutes = (milliseconds) => toSeconds(milliseconds) / 60;

    var toHours = (milliseconds) => toMinutes(milliseconds) / 60;

    var formatDuration = (duration, showSeconds = false) => {
        const hours = Math.floor(toHours(duration));
        const minutes = Math.floor(toMinutes(duration - fromHours(hours)));
        const seconds = Math.floor(toSeconds(duration - fromHours(hours) - fromMinutes(minutes)));
        return displayTime([hours, minutes, seconds], showSeconds);
    };

    var fromDays = (days) => fromHours(days * 24);

    var joinDateTime = (date, time) => `${date}T${time}`;

    var parseHourMinutePair = (text = "") => {
        const [hoursString, minutesString] = text.split(":");
        const hours = parseInt(hoursString || "0", 10);
        const minutes = parseInt(minutesString || "0", 10);
        return [hours, minutes];
    };

    var splitDateTime = (dateTimeString) => {
        const [date, time] = dateTimeString.split("T");
        return [date, time];
    };

    var subtractDays = (sourceDate, numberOfDays) => {
        const date = clone(sourceDate);
        date.setDate(date.getDate() - numberOfDays);
        return date;
    };

    var toDate = (date) => {
        const day = date.getDate();
        const month = date.getMonth() + 1;
        const year = date.getFullYear();
        return [
            `${year}`.padStart(4, "0"),
            `${month}`.padStart(2, "0"),
            `${day}`.padStart(2, "0")
        ].join("-");
    };

    var toDates = (xs) => xs.map(x => new Date(x));

    var toDays = (milliseconds) => toHours(milliseconds) / 24;

    var toISO = (x) => x.toISOString();

    var valid = (date) => date ? date instanceof Date && !Number.isNaN(date.valueOf()) : false;

    var date$1 = { clamp: clamp$1, clone, dateDiff, dateInRange, dayRange, daysInMonths, daysInYear, displayTime, endOfDay, formatDate, formatDateTime, formatDuration, formatTime, fromDays, fromHours, fromMinutes, fromSeconds, joinDateTime, leapYear, parseHourMinutePair, splitDateTime, startOfDay, subtractDays, toDate, toDates, toDays, toHours, toISO, toMinutes, toSeconds, valid };

    var isNumber = (x) => isNonNullable(x) &&
        typeof x === "number" &&
        !Number.isNaN(x) &&
        Number.isFinite(x);

    var integer = (x) => isNonNullable(x) && isNumber(x) && Math.floor(x) === x;

    var byte = (x) => isNonNullable(x) && integer(x) && x >= 0 && x <= 255;

    var normal = (x) => isNonNullable(x) && isNumber(x) && x >= 0 && x <= 1;

    var isString = (x) => typeof x === "string";

    var defined = (x) => x !== undefined;

    const assert = (condition, callbackOrMessage) => {
        if (!condition) {
            if (typeof callbackOrMessage === "function") {
                callbackOrMessage();
            }
            else {
                throw new TypeError(typeof callbackOrMessage === "string"
                    ? callbackOrMessage
                    : "Assertion failed!");
            }
        }
    };

    var entries = Object.entries;

    const implementation = (entries) => entries.reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});
    var fromEntries = (entries) => Object.fromEntries ? Object.fromEntries(entries) : implementation(entries);

    var filter = (f) => (xs) => fromEntries(entries(xs).filter(([key, value]) => f(value, key, xs)));

    var length$2 = (xs) => Object.keys(xs).length;

    var any = (xs) => (xs ? length$2(xs) > 0 : false);

    var none = (xs) => !any(xs);

    var array = (x) => (x ? Array.isArray(x) : false);

    var date = (x) => ({}.toString.apply(x) === "[object Date]");

    var _function$1 = (x) => typeof x === "function";

    var isObject = (x) => ({}.toString.apply(x) === "[object Object]");

    const VALUE_CREATED = "+";
    const VALUE_DELETED = "-";
    const VALUE_UNCHANGED = "=";
    const VALUE_UPDATED = "~";
    const isValue = (x) => !isObject(x) && !array(x);
    const compareValues = (value1, value2) => {
        if (value1 === value2) {
            return VALUE_UNCHANGED;
        }
        if (date(value1) &&
            date(value2) &&
            value1.getTime() === value2.getTime()) {
            return VALUE_UNCHANGED;
        }
        if (!defined(value1)) {
            return VALUE_CREATED;
        }
        if (!defined(value2)) {
            return VALUE_DELETED;
        }
        return VALUE_UPDATED;
    };
    const diff = (obj1, obj2) => {
        if (!obj1 || !obj2 || isValue(obj1) || isValue(obj2)) {
            const comparisonResult = compareValues(obj1, obj2);
            return comparisonResult !== VALUE_UNCHANGED
                ? {
                    type: comparisonResult,
                    data: [obj1, obj2]
                }
                : {};
        }
        const result = {};
        for (const key in obj1) {
            const value1 = obj1[key];
            if (_function$1(value1)) {
                continue;
            }
            const value2 = obj2[key];
            result[key] = diff(value1, value2);
        }
        for (const key in obj2) {
            const value2 = obj2[key];
            const existingValue = result[key];
            if (_function$1(value2) || defined(existingValue)) {
                continue;
            }
            result[key] = diff(undefined, value2);
        }
        return filter((value) => value !== null && !(value && isObject(value) && none(value)))(result);
    };

    var debug = { assert, diff };

    var from = (byteString) => [...byteString].map(_ => _.codePointAt(0) || 0);

    /* eslint-env browser, node */
    const ENCODING$1 = "utf-8";
    const atobImplementation = (text, context = typeof window !== "undefined"
        ? window
        : undefined) => context
        ? new context.TextDecoder(ENCODING$1).decode(new Uint8Array(from(context.atob(text))))
        : Buffer.from(text, "base64").toString(ENCODING$1);
    var decode = (text, context) => atobImplementation(text.replace(/-/g, "+").replace(/_/g, "/"), context);

    /* eslint-env browser, node */
    var decodeBytes = (text, context) => {
        const decoded = decode(text, context);
        return from(decoded);
    };

    var to = (bytes) => bytes.map(_ => String.fromCharCode(_)).join("");

    /* eslint-env browser, node */
    const toArray = (typedArray) => [...typedArray];
    const ENCODING = "utf-8";
    const btoaImplementation = (text, context = typeof window !== "undefined"
        ? window
        : undefined) => context
        ? context.btoa(to(toArray(new context.TextEncoder().encode(text))))
        : Buffer.from(text, ENCODING).toString("base64");
    var encode = (text, context) => btoaImplementation(text, context)
        .replace(/=/g, "")
        .replace(/\+/g, "-")
        .replace(/\//g, "_");

    /* eslint-env browser, node */
    var encodeBytes = (bytes, context) => {
        const sourceText = to(bytes);
        return encode(sourceText, context);
    };

    var fromBase64 = (base64) => base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");

    var toBase64 = (base64Url) => base64Url
        .replace(/-/g, "+")
        .replace(/_/g, "/")
        .padEnd(Math.ceil(base64Url.length / 4) * 4, "=");

    var base64url = { decode, decodeBytes, encode, encodeBytes, fromBase64, toBase64 };

    var byteString = { from, to };

    var encoding = { base64url, byteString };

    var validName = (name) => {
        // eslint-disable-next-line
        const forbiddenCharacters = /[<>:"\/\\|?*\x00-\x1F]/g;
        const forbiddenNames = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
        return !forbiddenCharacters.test(name) && !forbiddenNames.test(name);
    };

    var file = { validName };

    var compose = (...fs) => (x) => fs.reduceRight((x, f) => f(x), x);

    var constant = (x) => () => x;

    var identity = (x) => x;

    const keySet = (a, b) => [
        ...new Set([...Object.keys(a), ...Object.keys(b)])
    ];
    const equalsDeepWith = (f) => (a, b) => {
        if (areArrays(a, b)) {
            return (!lengthDiffers(a, b) &&
                a.every((_, key) => equalsDeepWith(f)(_, b[key])));
        }
        return isObject(a) && isObject(b)
            ? a === b || keySet(a, b).every(key => equalsDeepWith(f)(a[key], b[key]))
            : f(a, b);
    };
    const defaultEquals = (a, b) => a === b;
    const equalsDeep = equalsDeepWith(defaultEquals);

    var memoizeWith = (equals) => (f) => {
        let memoized = undefined;
        let memoizedArgs = undefined;
        return (...args) => {
            if (memoized && equals(args, memoizedArgs)) {
                return memoized;
            }
            memoized = f(...args);
            memoizedArgs = args;
            return memoized;
        };
    };

    var memoize = memoizeWith(equalsDeep);

    const equalsShallow = (xs, ys) => xs.length === ys.length && xs.every((x, index) => x === ys[index]);
    var memoizeShallow = memoizeWith(equalsShallow);

    var noOp = () => { };

    var not = (f) => (...args) => !f(...args);

    var pipe = (...fs) => (x) => fs.reduce((x, f) => f(x), x);

    var when = (predicate) => (action) => (...args) => {
        if (predicate(...args)) {
            return action(...args);
        }
    };

    var whenTrue = when(x => x === true);

    var _function = { compose, constant, identity, memoize, memoizeShallow, memoizeWith, noOp, not, pipe, when, whenTrue };

    var boolean = (x) => typeof x === "boolean";

    var is = { array, boolean, byte, date, defined, _function: _function$1, integer, nonNullable: isNonNullable, normal, number: isNumber, object: isObject, string: isString };

    var add$1 = (a, b) => a + b;

    var average = (xs) => xs && xs.length > 0 ? sum(xs) / xs.length : 0;

    var ceilToNearestPowerOfTwo = (x) => Math.pow(2, Math.ceil(Math.log(x) / Math.log(2)));

    var clamp = (min, max) => (x) => Math.max(min, Math.min(max, x));

    var clampNormal = clamp(0, 1);

    var clampPercentage = clamp(0, 100);

    var delta = (a, b) => Math.abs(a - b);

    var inRectangleRange = (width, height) => (x, y) => x >= 0 && x <= width && y >= 0 && y <= height;

    var lerp = (t) => (a, b) => a * (1 - t) + b * t;

    var maximumBy = (f) => (xs) => xs.reduce((acc, curr) => (f(curr) > f(acc) ? curr : acc));

    var subtract = (a, b) => a - b;

    var median = (xs) => {
        if (!xs || xs.length === 0) {
            return undefined;
        }
        const sorted = sort$1(subtract)(xs);
        const middle = Math.floor(sorted.length / 2);
        if (sorted.length % 2 === 0) {
            return (sorted[middle - 1] + sorted[middle]) / 2;
        }
        return sorted[middle];
    };

    var minMax = ([a, b]) => a > b ? [b, a] : [a, b];

    var sign = (x) => (x !== 0 ? x / Math.abs(x) : 0);

    const filterOutZeros = (xs) => xs.filter((_) => _ !== 0);
    var sameSign = (xs) => {
        const filteredXs = filterOutZeros(xs);
        return Math.abs(filteredXs.map(sign).reduce(add$1, 0)) === filteredXs.length;
    };

    var standardDeviation = (xs, origin = average(xs)) => {
        const sumOfSquareDifferences = xs.reduce((squareDiffs, x) => squareDiffs + Math.pow(x - origin, 2), 0);
        return Math.sqrt(sumOfSquareDifferences / (xs.length - 1));
    };

    var math = { add: add$1, average, ceilToNearestPowerOfTwo, clamp, clampNormal, clampPercentage, delta, inRectangleRange, lerp, maximumBy, median, minMax, sameSign, sign, standardDeviation, subtract };

    var apply = (fs) => (...xs) => fromEntries(entries(fs).map(([key, value]) => [key, value(...xs)]));

    var empty$2 = {};

    var enumerable = (...xs) => xs.reduce((acc, curr) => ({ ...acc, [curr]: curr }), {});

    var every = (f) => (xs) => entries(xs).every(([key, value]) => f(value, key, xs));

    var findEntry = (predicate) => (xs) => entries(xs).find(([key, value]) => predicate(value, key, xs));

    var find = (predicate) => (xs) => {
        const [, value] = findEntry(predicate)(xs) || [];
        return value;
    };

    var findKey = (predicate) => (xs) => {
        const [key] = findEntry(predicate)(xs) || [];
        return key;
    };

    var first = (xs) => Object.values(xs)[0];

    var flatMapValues = (f) => (xs) => flatMap(([key, value]) => f(value, key, xs))(entries(xs));

    var groupBy = (selector) => (xs) => xs.reduce((acc, x) => {
        const key = selector(x);
        return { ...acc, [key]: [...(acc[key] || []), x] };
    }, {});

    var hasKey = (key) => (xs) => xs ? Object.prototype.hasOwnProperty.call(xs, key) : false;

    var mapEntries = (f) => (xs) => entries(xs).map(([key, value]) => [key, f(value, key, xs)]);

    var map = (f) => (xs) => fromEntries(mapEntries(f)(xs));

    var mapKeys = (f) => (xs) => fromEntries(entries(xs).map(([key, value]) => [f(value, key, xs), value]));

    var mapValues = (f) => (xs) => entries(xs).map(([key, value]) => f(value, key, xs));

    const isNonNullableObject = (x) => isNonNullable(x) && isObject(x);
    const merge = (a, b) => ({
        ...a,
        ...map((value, key) => isNonNullableObject(value) && isNonNullableObject(a[key])
            ? merge(a[key], value)
            : value)(b)
    });

    var some = (f) => (xs) => entries(xs).some(([key, value]) => f(value, key, xs));

    var sort = (f) => (xs) => fromEntries(sort$1(([, a], [, b]) => f(a, b))(entries(xs)));

    var object = { any, apply, empty: empty$2, entries, enumerable, equals: equalsDeep, every, filter, find, findEntry, findKey, first, flatMapValues, fromEntries, groupBy, hasKey, length: length$2, map, mapEntries, mapKeys, mapValues, merge, none, some, sort };

    var startsWith = (prefix) => (xs) => xs.indexOf(prefix) === 0;

    const startsWithQuestionMark = startsWith("?");
    const queryFromMaybeSearchString = (x) => startsWithQuestionMark(x) ? x.substring(1) : x;
    var parse = (xs = "") => fromEntries(queryFromMaybeSearchString(xs)
        .split("&")
        .filter(Boolean)
        .map(xs => {
        const [key, value] = xs.split("=");
        return [key, value !== undefined ? decodeURIComponent(value) : true];
    }));

    /* eslint-env browser */
    var read = (source) => [...new URLSearchParams(source).entries()].reduce((q, [k, v]) => ({ ...q, ...{ [k]: v } }), {});

    var serialize = (xs = {}) => entries(xs)
        .filter(([, value]) => Boolean(value) || value === 0)
        .map(pair => pair.map(value => encodeURIComponent(value)))
        .reduce((acc, [key, value]) => [
        ...acc,
        xs[key] === true ? key : `${key}=${value}`
    ], [])
        .join("&");

    var query = { parse, read, serialize };

    var empty$1 = ([min, max]) => min === max;

    var equals = ([a, b], [c, d]) => a === c && b === d;

    var length$1 = ([min, max]) => max - min;

    const split = (used, sourceRange = [-Infinity, Infinity]) => (range) => {
        if (empty$1(range) || !range.every(isNumber)) {
            return [];
        }
        if (!used || used.length === 0) {
            return [range];
        }
        const [x, ...xs] = used;
        const [usedMin, usedMax] = x;
        if (empty$1(x)) {
            return split(xs, sourceRange)(range);
        }
        const [sourceMin, sourceMax] = sourceRange;
        const clampToSourceRange = clamp(sourceMin, sourceMax);
        const [freeLeftMin, freeLeftMax] = [sourceMin, usedMin].map(clampToSourceRange);
        const [freeRightMin, freeRightMax] = [usedMax, sourceMax].map(clampToSourceRange);
        const clampLeft = clamp(freeLeftMin, freeLeftMax);
        const [clampedLeftMin, clampedLeftMax] = range.map(clampLeft);
        const lefts = split(xs, sourceRange)([clampedLeftMin, clampedLeftMax]);
        const clampRight = clamp(freeRightMin, freeRightMax);
        const [clampedRightMin, clampedRightMax] = range.map(clampRight);
        const rights = split(xs, sourceRange)([clampedRightMin, clampedRightMax]);
        return [...lefts, ...rights].filter(range => !empty$1(range));
    };

    var range = { empty: empty$1, equals, length: length$1, split };

    var escape = (string) => string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");

    var regex = { escape };

    var containsWhitespace = (x) => /\s/.test(x);

    var empty = "";

    var firstToLower = (text) => {
        if (!text) {
            return "";
        }
        const [first, ...rest] = text;
        return [first.toLowerCase(), ...rest].join("");
    };

    var firstToUpper = (text) => {
        if (!text) {
            return "";
        }
        const [first, ...rest] = text;
        return [first.toUpperCase(), ...rest].join("");
    };

    var includes = (search) => (text) => text.indexOf(search) !== -1;

    var nbsp = "\u00A0";

    var nonEmpty = (x) => Boolean(x && x.trim());

    var string = { containsWhitespace, empty, firstToLower, firstToUpper, includes, nbsp, nonEmpty, startsWith };

    var add = ([x1, y1], [x2, y2]) => [x1 + x2, y1 + y2];

    var mul = ({ a, b, c, d, e, f }, [x, y]) => [a * x + c * y + e, b * x + d * y + f];

    var convertSpace = (space) => ([x, y]) => {
        const [outX, outY] = mul(space, [x, y]);
        return [outX, outY];
    };

    var cross = ([a, b], [c, d]) => a * d - b * c;

    var dot = ([a, b], [c, d]) => a * c + b * d;

    var length = ([x, y]) => Math.sqrt(x ** 2 + y ** 2);

    var multiply = (m1, m2) => ({
        a: m1.a * m2.a + m1.c * m2.b,
        c: m1.a * m2.c + m1.c * m2.d,
        e: m1.a * m2.e + m1.c * m2.f + m1.e,
        b: m1.b * m2.a + m1.d * m2.b,
        d: m1.b * m2.c + m1.d * m2.d,
        f: m1.b * m2.e + m1.d * m2.f + m1.f
    });

    var normalize = (vector) => {
        const magnitude = length(vector);
        const [x, y] = vector;
        return magnitude !== 0 ? [x / magnitude, y / magnitude] : vector;
    };

    var sub = ([x1, y1], [x2, y2]) => [x1 - x2, y1 - y2];

    var reflect = (a, v) => {
        const [ax, ay] = a;
        const selfDot = dot(a, a);
        return sub(v, [
            (ax * 2 * dot(v, a)) / selfDot,
            (ay * 2 * dot(v, a)) / selfDot
        ]);
    };

    var transform = (...matrices) => matrices.reduce(multiply);

    var translate = (tx = 0, ty = tx) => ({
        a: 1,
        c: 0,
        e: tx,
        b: 0,
        d: 1,
        f: ty
    });

    const { cos, sin } = Math;
    var rotate = (angle = 0, cx = 0, cy = 0) => {
        const cosAngle = cos(angle);
        const sinAngle = sin(angle);
        const rotationMatrix = {
            a: cosAngle,
            c: -sinAngle,
            e: 0,
            b: sinAngle,
            d: cosAngle,
            f: 0
        };
        return transform(translate(cx, cy), rotationMatrix, translate(-cx, -cy));
    };

    var scale = (sx = 1, sy = sx) => ({
        a: sx,
        c: 0,
        e: 0,
        b: 0,
        d: sy,
        f: 0
    });

    var vector2 = { add, convertSpace, cross, dot, length, mul, multiply, normalize, reflect, rotate, scale, sub, transform, translate };

    const booleanKeys = (xs) => entries(xs)
        .filter(([, value]) => Boolean(value))
        .map(([key]) => key);
    var classNames = (...xs) => xs
        .filter(Boolean)
        .reduce((acc, curr) => {
        const names = isString(curr) ? [curr] : booleanKeys(curr);
        return [...acc, ...names];
    }, [])
        .join(" ");

    var prevent = (event) => {
        event.preventDefault();
        return false;
    };

    var stop = (event) => {
        event.stopPropagation();
        return false;
    };

    var cancel = (event) => {
        prevent(event);
        stop(event);
        return false;
    };

    var openInNewTabIntent = ({ button, ctrlKey, metaKey, shiftKey }) => Boolean(ctrlKey || shiftKey || metaKey || button === 1);

    var events = { cancel, openInNewTabIntent, prevent, stop };

    var web = { classNames, events };

    var index = { array: array$1, async, date: date$1, debug, encoding, file, _function, is, math, object, query, range, regex, string, vector2, web };

    exports._function = _function;
    exports.array = array$1;
    exports.async = async;
    exports.date = date$1;
    exports.debug = debug;
    exports.default = index;
    exports.encoding = encoding;
    exports.file = file;
    exports.is = is;
    exports.math = math;
    exports.object = object;
    exports.query = query;
    exports.range = range;
    exports.regex = regex;
    exports.string = string;
    exports.vector2 = vector2;
    exports.web = web;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
