import any from "./any";
import are from "./are";
import chunk from "./chunk";
import difference from "./difference";
import differs from "./differs";
import duplicates from "./duplicates";
import empty from "./empty";
import exact from "./exact";
import except from "./except";
import filterInPlace from "./filterInPlace";
import find from "./find";
import first from "./first";
import flatMap from "./flatMap";
import flatten from "./flatten";
import insert from "./insert";
import intersection from "./intersection";
import is from "./is";
import last from "./last";
import length from "./length";
import lengthDiffers from "./lengthDiffers";
import map from "./map";
import midpoint from "./midpoint";
import minMax from "./minMax";
import multiple from "./multiple";
import none from "./none";
import partition from "./partition";
import pop from "./pop";
import range from "./range";
import removeAt from "./removeAt";
import repeat from "./repeat";
import reverse from "./reverse";
import reverseIf from "./reverseIf";
import second from "./second";
import secondToLast from "./secondToLast";
import shift from "./shift";
import shuffle from "./shuffle";
import shuffleInPlace from "./shuffleInPlace";
import single from "./single";
import skip from "./skip";
import slidingWindow from "./slidingWindow";
import sort from "./sort";
import sum from "./sum";
import take from "./take";
import unique from "./unique";
import uniqueBy from "./uniqueBy";
import zip from "./zip";
import zipN from "./zipN";
import zipWith from "./zipWith";

export {
  any,
  are,
  chunk,
  difference,
  differs,
  duplicates,
  empty,
  exact,
  except,
  filterInPlace,
  find,
  first,
  flatMap,
  flatten,
  insert,
  intersection,
  is,
  last,
  length,
  lengthDiffers,
  map,
  midpoint,
  minMax,
  multiple,
  none,
  partition,
  pop,
  range,
  removeAt,
  repeat,
  reverse,
  reverseIf,
  second,
  secondToLast,
  shift,
  shuffle,
  shuffleInPlace,
  single,
  skip,
  slidingWindow,
  sort,
  sum,
  take,
  unique,
  uniqueBy,
  zip,
  zipN,
  zipWith
};
declare const _default: {
  any: (xs?: any[]) => boolean;
  are: (...xs: any[]) => boolean;
  chunk: (count: number) => (xs: any[]) => any[];
  difference: (xs: any[], ys: any[]) => any[];
  differs: (xs?: any[], ys?: any[]) => boolean;
  duplicates: (xs: any[]) => any[];
  empty: any[];
  exact: (count: number) => (xs: any[]) => any[];
  except: (y: any) => (xs: any[]) => any[];
  filterInPlace: (
    f: (value: any, index: number, context: any[]) => boolean
  ) => (xs: any[]) => any[];
  find: (
    predicate: (value: any, index: number, context: any[]) => boolean,
    fallback?: any
  ) => (xs: any[]) => any;
  first: ([x]: [any]) => any;
  flatMap: (
    f: (value: any, index: number, context: any[]) => any
  ) => (xs: any[]) => any;
  flatten: (xs: any) => any[];
  insert: (index: number) => (item: any) => ([...xs]: any[]) => any[];
  intersection: (xs: any[], ys: any[]) => any[];
  is: (value?: any) => boolean;
  last: (xs: any[]) => any;
  length: (xs: any[]) => number;
  lengthDiffers: (a: any[], b: any[]) => boolean;
  map: (...fs: ((x: any) => any)[]) => (xs: any) => any;
  midpoint: (xs: any[]) => any;
  minMax: (xs: number[]) => number[];
  multiple: (xs: any) => boolean;
  none: (xs?: any) => boolean;
  partition: (predicate: (x: any) => boolean) => (xs: any[]) => any;
  pop: (xs: any[]) => any[];
  range: (n: any) => number[];
  removeAt: (index: number) => (xs: any[]) => any[];
  repeat: (count: number) => (value: any) => any[];
  reverse: (xs: any) => any[];
  reverseIf: (enabled: boolean) => (xs: any) => any;
  second: (xs: any[]) => any;
  secondToLast: (xs: any[]) => any;
  shift: (count: number) => (xs: any[]) => any[];
  shuffle: (xs: any, random?: () => number) => any[];
  shuffleInPlace: (xs: any[], random?: () => number) => any[];
  single: (xs: any[]) => boolean;
  skip: (count: number) => (xs: any[]) => any[];
  slidingWindow: (count: number) => (xs: any[]) => any[][];
  sort: (f?: (a: any, b: any) => number) => (xs: any[]) => any[];
  sum: (xs: number[]) => number;
  take: (count: number) => (xs: any[]) => any[];
  unique: (xs: any[]) => any[];
  uniqueBy: (f: (x: any) => any) => (xs: any[]) => any[];
  zip: (xs: any[], ys: any[]) => any[][];
  zipN: (...xs: any[][]) => any[][];
  zipWith: (f?: (x: any, y: any) => any[]) => (xs: any[], ys: any[]) => any[][];
};

export default _default;
