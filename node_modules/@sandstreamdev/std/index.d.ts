import array from "./array/index";
import async from "./async/index";
import date from "./date/index";
import debug from "./debug/index";
import encoding from "./encoding/index";
import file from "./file/index";
import _function from "./function/index";
import is from "./is/index";
import math from "./math/index";
import object from "./object/index";
import query from "./query/index";
import range from "./range/index";
import regex from "./regex/index";
import string from "./string/index";
import vector2 from "./vector2/index";
import web from "./web/index";

export {
  array,
  async,
  date,
  debug,
  encoding,
  file,
  _function,
  is,
  math,
  object,
  query,
  range,
  regex,
  string,
  vector2,
  web
};
declare const _default: {
  array: {
    any: (xs?: any[]) => boolean;
    are: (...xs: any[]) => boolean;
    chunk: (count: number) => (xs: any[]) => any[];
    difference: (xs: any[], ys: any[]) => any[];
    differs: (xs?: any[], ys?: any[]) => boolean;
    duplicates: (xs: any[]) => any[];
    empty: any[];
    exact: (count: number) => (xs: any[]) => any[];
    except: (y: any) => (xs: any[]) => any[];
    filterInPlace: (
      f: (value: any, index: number, context: any[]) => boolean
    ) => (xs: any[]) => any[];
    find: (
      predicate: (value: any, index: number, context: any[]) => boolean,
      fallback?: any
    ) => (xs: any[]) => any;
    first: ([x]: [any]) => any;
    flatMap: (
      f: (value: any, index: number, context: any[]) => any
    ) => (xs: any[]) => any;
    flatten: (xs: any) => any[];
    insert: (index: number) => (item: any) => ([...xs]: any[]) => any[];
    intersection: (xs: any[], ys: any[]) => any[];
    is: (value?: any) => boolean;
    last: (xs: any[]) => any;
    length: (xs: any[]) => number;
    lengthDiffers: (a: any[], b: any[]) => boolean;
    map: (...fs: ((x: any) => any)[]) => (xs: any) => any;
    midpoint: (xs: any[]) => any;
    minMax: (xs: number[]) => number[];
    multiple: (xs: any) => boolean;
    none: (xs?: any) => boolean;
    partition: (predicate: (x: any) => boolean) => (xs: any[]) => any;
    pop: (xs: any[]) => any[];
    range: (n: any) => number[];
    removeAt: (index: number) => (xs: any[]) => any[];
    repeat: (count: number) => (value: any) => any[];
    reverse: (xs: any) => any[];
    reverseIf: (enabled: boolean) => (xs: any) => any;
    second: (xs: any[]) => any;
    secondToLast: (xs: any[]) => any;
    shift: (count: number) => (xs: any[]) => any[];
    shuffle: (xs: any, random?: () => number) => any[];
    shuffleInPlace: (xs: any[], random?: () => number) => any[];
    single: (xs: any[]) => boolean;
    skip: (count: number) => (xs: any[]) => any[];
    slidingWindow: (count: number) => (xs: any[]) => any[][];
    sort: (f?: (a: any, b: any) => number) => (xs: any[]) => any[];
    sum: (xs: number[]) => number;
    take: (count: number) => (xs: any[]) => any[];
    unique: (xs: any[]) => any[];
    uniqueBy: (f: (x: any) => any) => (xs: any[]) => any[];
    zip: (xs: any[], ys: any[]) => any[][];
    zipN: (...xs: any[][]) => any[][];
    zipWith: (
      f?: (x: any, y: any) => any[]
    ) => (xs: any[], ys: any[]) => any[][];
  };
  async: {
    debounce: (
      f: (...args: any[]) => any,
      wait: number
    ) => (...args: any[]) => void;
    delay: (duration: number) => Promise<unknown>;
    sequence: (tasks: (() => Promise<any>)[]) => Promise<any[]>;
  };
  date: {
    clamp: (min: Date, max: Date) => (date: Date) => Date;
    clone: (date: Date) => Date;
    dateDiff: (a: Date, b: Date) => number;
    dateInRange: (from: Date, to: Date) => (date: Date) => boolean;
    dayRange: (date: Date) => Date[];
    daysInMonths: (
      leapYear: boolean
    ) => [
      number,
      number,
      number,
      number,
      number,
      number,
      number,
      number,
      number,
      number,
      number,
      number
    ];
    daysInYear: (year: number) => 366 | 365;
    displayTime: (
      source: [number, number, number],
      showSeconds: boolean
    ) => string;
    endOfDay: (date: Date) => Date;
    formatDate: (date: Date) => string;
    formatDateTime: (sourceDate: Date, showSeconds?: boolean) => string;
    formatDuration: (duration: number, showSeconds?: boolean) => string;
    formatTime: (date: Date, showSeconds?: boolean) => string;
    fromDays: (days: number) => number;
    fromHours: (hours: number) => number;
    fromMinutes: (minutes: number) => number;
    fromSeconds: (seconds: number) => number;
    joinDateTime: (date: string, time: string) => string;
    leapYear: (year: number) => boolean;
    parseHourMinutePair: (text?: string) => [number, number];
    splitDateTime: (dateTimeString: string) => [string, string];
    startOfDay: (date: Date) => Date;
    subtractDays: (sourceDate: Date, numberOfDays: number) => Date;
    toDate: (date: Date) => string;
    toDates: (xs: (string | number | Date)[]) => Date[];
    toDays: (milliseconds: number) => number;
    toHours: (milliseconds: number) => number;
    toISO: (x: Date) => string;
    toMinutes: (milliseconds: number) => number;
    toSeconds: (milliseconds: number) => number;
    valid: (date?: any) => boolean;
  };
  debug: {
    assert: (
      condition: boolean,
      callbackOrMessage: string | (() => void)
    ) => void;
    diff: (
      obj1?: {
        [index: string]: any;
      },
      obj2?: {
        [index: string]: any;
      }
    ) => object;
  };
  encoding: {
    base64url: {
      decode: (
        text: string,
        context?: import("./encoding/base64url/DecodeContext.interface").DecodeContext
      ) => string;
      decodeBytes: (
        text: string,
        context?: import("./encoding/base64url/DecodeContext.interface").DecodeContext
      ) => number[];
      encode: (
        text: string,
        context?: import("./encoding/base64url/EncodeContext.interface").EncodeContext
      ) => string;
      encodeBytes: (
        bytes: number[],
        context?: import("./encoding/base64url/EncodeContext.interface").EncodeContext
      ) => string;
      fromBase64: (base64: string) => string;
      toBase64: (base64Url: string) => string;
    };
    byteString: {
      from: (byteString: string) => number[];
      to: (bytes: number[]) => string;
    };
  };
  file: {
    validName: (name: string) => boolean;
  };
  _function: {
    compose: (...fs: ((x: any) => any)[]) => (x: any) => any;
    constant: (x: any) => any;
    identity: (x: any) => any;
    memoize: (f: (...xs: any[]) => any) => (...args: any[]) => any;
    memoizeShallow: (f: (...xs: any[]) => any) => (...args: any[]) => any;
    memoizeWith: (
      equals: (x: any, y: any) => boolean
    ) => (f: (...xs: any[]) => any) => (...args: any[]) => any;
    noOp: () => void;
    not: (f: (...xs: any[]) => any) => (...args: any[]) => boolean;
    pipe: (...fs: ((x: any) => any)[]) => (x: any) => any;
    when: (
      predicate: (...xs: any[]) => boolean
    ) => (action: (...xs: any[]) => any) => (...args: any[]) => any;
    whenTrue: (action: (...xs: any[]) => any) => (...args: any[]) => any;
  };
  is: {
    array: (x?: any) => boolean;
    boolean: (x?: any) => boolean;
    byte: (x?: number) => boolean;
    date: (x?: any) => boolean;
    defined: (x?: any) => boolean;
    _function: (x?: any) => boolean;
    integer: (x?: number) => boolean;
    nonNullable: <T>(val: T) => val is NonNullable<T>;
    normal: (x?: number) => boolean;
    number: (x?: any) => boolean;
    object: (x?: any) => boolean;
    string: (x?: any) => boolean;
  };
  math: {
    add: (a: number, b: number) => number;
    average: (xs?: number[]) => number;
    ceilToNearestPowerOfTwo: (x: number) => number;
    clamp: (min: number, max: number) => (x: number) => number;
    clampNormal: (x: number) => number;
    clampPercentage: (x: number) => number;
    delta: (a: number, b: number) => number;
    inRectangleRange: (
      width: number,
      height: number
    ) => (x: number, y: number) => boolean;
    lerp: (t: number) => (a: number, b: number) => number;
    maximumBy: (f: (x: number) => number) => (xs: number[]) => number;
    median: (xs?: number[]) => number;
    minMax: ([a, b]: [number, number]) => [number, number];
    sameSign: (xs: number[]) => boolean;
    sign: (x: number) => number;
    standardDeviation: (xs: number[], origin?: number) => number;
    subtract: (a: number, b: number) => number;
  };
  object: {
    any: (xs?: object) => boolean;
    apply: (fs: ((...xs: any[]) => any)[]) => (...xs: any[]) => object;
    empty: {};
    entries: {
      <T_1>(
        o:
          | {
              [s: string]: T_1;
            }
          | ArrayLike<T_1>
      ): [string, T_1][];
      (o: {}): [string, any][];
    };
    enumerable: (...xs: string[]) => object;
    equals: (a: any, b: any) => boolean;
    every: (
      f: (value: any, key: string, context: object) => boolean
    ) => (xs: object) => boolean;
    filter: (
      f: (value: any, key: string, context: object) => boolean
    ) => (xs: object) => object;
    find: (
      predicate: (value: any, key: string, context: object) => boolean
    ) => (xs: object) => any;
    findEntry: (
      predicate: (value: any, key: string, context: object) => boolean
    ) => (xs: object) => any;
    findKey: (
      predicate: (value: any, key: string, context: object) => boolean
    ) => (xs: object) => any;
    first: (xs: object) => any;
    flatMapValues: (
      f: (value: any, key: string, context: object) => any
    ) => (xs: object) => any[];
    fromEntries: (entries: [string, any][]) => object;
    groupBy: (selector: (x: any) => string) => (xs: any[]) => object;
    hasKey: (key: string) => (xs?: any) => any;
    length: (xs: object) => number;
    map: (
      f: (value: any, key: string, context: object) => any
    ) => (xs: object) => object;
    mapEntries: (
      f: (value: any, key: string, context: object) => any
    ) => (xs: object) => [string, any][];
    mapKeys: (
      f: (value: any, key: string, context: object) => any
    ) => (xs: object) => object;
    mapValues: (
      f: (value: any, key: string, context: object) => any
    ) => (xs: object) => any[];
    merge: (
      a: {
        [index: string]: any;
      },
      b: object
    ) => object;
    none: (xs?: object) => boolean;
    some: (
      f: (value: any, key: string, context: object) => boolean
    ) => (xs: object) => boolean;
    sort: (f: (a: any, b: any) => number) => (xs: object) => object;
  };
  query: {
    parse: (xs?: string) => object;
    read: (source: string) => {};
    serialize: (xs?: { [index: string]: any }) => string;
  };
  range: {
    empty: ([min, max]: [number, number]) => boolean;
    equals: ([a, b]: [number, number], [c, d]: [number, number]) => boolean;
    length: ([min, max]: [number, number]) => number;
    split: (
      used: [number, number][],
      sourceRange?: number[]
    ) => (range: [number, number]) => [number, number][];
  };
  regex: {
    escape: (string: string) => string;
  };
  string: {
    containsWhitespace: (x: string) => boolean;
    empty: string;
    firstToLower: (text: string) => string;
    firstToUpper: (text: string) => string;
    includes: (search: string) => (text: string) => boolean;
    nbsp: string;
    nonEmpty: (x?: string) => boolean;
    startsWith: (prefix: string) => (xs: string) => boolean;
  };
  vector2: {
    add: (
      [x1, y1]: [number, number],
      [x2, y2]: [number, number]
    ) => [number, number];
    convertSpace: (space: {
      a: number;
      c: number;
      e: number;
      b: number;
      d: number;
      f: number;
    }) => ([x, y]: [number, number]) => number[];
    cross: ([a, b]: [number, number], [c, d]: [number, number]) => number;
    dot: ([a, b]: [number, number], [c, d]: [number, number]) => number;
    length: ([x, y]: [number, number]) => number;
    mul: (
      {
        a,
        b,
        c,
        d,
        e,
        f
      }: {
        a: number;
        c: number;
        e: number;
        b: number;
        d: number;
        f: number;
      },
      [x, y]: [number, number]
    ) => number[];
    multiply: (
      m1: {
        a: number;
        c: number;
        e: number;
        b: number;
        d: number;
        f: number;
      },
      m2: {
        a: number;
        b: number;
        c: number;
        d: number;
        e: number;
        f: number;
      }
    ) => {
      a: number;
      c: number;
      e: number;
      b: number;
      d: number;
      f: number;
    };
    normalize: (vector: [number, number]) => [number, number];
    reflect: (a: [number, number], v: [number, number]) => [number, number];
    rotate: (
      angle?: number,
      cx?: number,
      cy?: number
    ) => {
      a: number;
      c: number;
      e: number;
      b: number;
      d: number;
      f: number;
    };
    scale: (
      sx?: number,
      sy?: number
    ) => {
      a: number;
      c: number;
      e: number;
      b: number;
      d: number;
      f: number;
    };
    sub: (
      [x1, y1]: [number, number],
      [x2, y2]: [number, number]
    ) => [number, number];
    transform: (
      ...matrices: {
        a: number;
        c: number;
        e: number;
        b: number;
        d: number;
        f: number;
      }[]
    ) => {
      a: number;
      c: number;
      e: number;
      b: number;
      d: number;
      f: number;
    };
    translate: (
      tx?: number,
      ty?: number
    ) => {
      a: number;
      c: number;
      e: number;
      b: number;
      d: number;
      f: number;
    };
  };
  web: {
    classNames: (...xs: any[]) => any;
    events: {
      cancel: (event: {
        preventDefault: () => void;
        stopPropagation: () => void;
      }) => boolean;
      openInNewTabIntent: ({
        button,
        ctrlKey,
        metaKey,
        shiftKey
      }: {
        button?: number;
        ctrlKey?: boolean;
        metaKey?: boolean;
        shiftKey?: boolean;
      }) => boolean;
      prevent: (event: { preventDefault: () => void }) => boolean;
      stop: (event: { stopPropagation: () => void }) => boolean;
    };
  };
};

export default _default;
